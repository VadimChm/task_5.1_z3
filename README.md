# task_5.1_z3
Задача состояла в том, чтобы попробовать написать в терминах Z3 какую-нибудь сортировку.
Тут я попробовал использовать API z3 для c++.

Рассмотрим основную идею, релизованную тут на примере _"сортировки"_ массива из двух элементов.
Есть элементы `x_0` и `x_1` - перемнные, которые в терминах z3 могут иметь произвольное значение и не имеют конкретного значения на момент их рассмотрения.
Хотим совершить с ними некоторые действия, чтобы после выполнения программы наш массив был отсортирован.

1) Уже имеем две переменные - `x_0`, `x_1`.
2) Заводим еще одну логическую переменную `swap`, которая отвечает за то, поменялись ли они местами в ходе выполнения программы.
3) На вход z3-солверу подаем логическое выражение вида `x_0 > x_1 && swap`. Тут мы как бы говорим _"если элементы стоят в неверном порядке, то `swap = true`"_.
4) Проверяем готовый массив на НЕупорядоченность. Т.е. подаем на вход еще одно выражение вида `(x_0 > x_1 && !swap) || (x_1 > x_0 && swap)`. То есть _"если или элементы уже упорядочены и мы их поменяли или они упорядочены неверно и НЕ были поменяны местами"_.

Таким образом у солвера есть выражение
`(x_0 > x_1 && swap) && ((x_0 > x_1 && !swap) || (x_1 > x_0 && swap))`. 
После проверки солвер либо найдет набор значений переменных при которых выражение выполнено (т.е. сортировка не удалась), либо скажет, что все ок.

В этом случае выражение разрешимо только при условии, что разрешимо выражение в первой скобке, но тогда выражение во второй автоматически неверно, а наша _"сортировка"_ верна.

В программе представлены функции `check_compare`, которая составляет для z3 логичекое выражение, которое является как бы проверкой отношения порядка i-го и j-го элементов с учетом всех сделанных (или не сделанных) перестановок, а функция `add_swap_conjuction` подает на вход солверу выражение вида _"если условие выполнено, то поменять элементы"_.
Таким образом имеем функционал, с помощью которого может быть написана любая сортировка без дополнительной памяти.
Например Пузырек (в этом примере).
К сожалению размер логических выражений экспоненциально увеличивается с количесвом перестановок, поэтому на больших размерах массива проверить не удается)
У меня получилось проверить на массиве размера <= 7.
